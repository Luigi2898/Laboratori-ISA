
vcom Message # 1001:
For the -skip and -just options, one or more of the following design
unit indications must be specified:
  e or E - entities
  a or A - architectures
  p or P - packages
  b or B - package bodies
  c or C - configurations
[DOC: ModelSim Command Reference - vcom command]


vcom Message # 1002:
While attempting to bind a component to an entity, a generic of the
specified name which appears in the specified component declaration was
not found to be declared as a formal generic in the specified entity.
This message may be displayed as a warning if the entity is being chosen
for a default binding. If the default binding is overridden later by a
specific binding, then this warning can be ignored. Otherwise, this is
an elaboration error. The warning version of this message is controlled by
the vcom option -nowarn 1.
[DOC: IEEE Std 1076-2002 VHDL LRM - 5.2.2 Default binding indication]


vcom Message # 1003:
No more than the specified number of -noaccel options can be specified.
All -noaccel options encountered after the limit is reached are ignored.


vcom Message # 1004:
Design unit dependencies have changed since the last time this design
unit was compiled, therefore it should be recompiled instead of
refreshed. You can force the design unit to be refreshed by using the
-force_refresh option but this might result in incorrect simulation.


vcom Message # 1005:
An fseek() on the source file being copied to the specified destination
file failed. This message might be followed by another message that
gives more information about the problem.


vcom Message # 1006:
An fread() on the source file being copied to the specified destination
file unexpectedly encountered an end-of-file condition. This message
might be followed by another message that gives more information about
the problem.


vcom Message # 1007:
An fread() on the source file being copied to the specified destination
file failed. This message might be followed by another message that
gives more information about the problem.


vcom Message # 1008:
An fwrite() on the specified file failed. This message might be followed
by another message that gives more information about the problem.


vcom Message # 1009:
The array bounds of the result of the implicit "&" operator are being
computed using the 1993 rules because the 1987 rules are untenable.
This may be important when this result is used as the actual to a
subprogram call (when the formal is an unconstrained array type)
because the formal takes on the bounds of the actual.
[DOC: IEEE Std 1076-1993 VHDL LRM - 7.2.4 Adding operators]
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.2.1.1 Index constraints and discrete ranges]


vcom Message # 1010:
The slice is a null slice if the direction of the discrete range is not
the same as that of the object denoted by the prefix of the slice name.
[DOC: IEEE Std 1076-1987 VHDL LRM - 6.5 Slice names]
This was changed to an error in VHDL 1993, see message #1012.


vcom Message # 1011:
It is impossible to create a null slice (see warning message #1010) when
the bounds of the discrete range are identical.


vcom Message # 1012:
It is an error if the direction of the discrete range of a slice name
is not the same as that of the index range of the array denoted by the
prefix of the slice name.
[DOC: IEEE Std 1076-1993 VHDL LRM - 6.5 Slice names]


vcom Message # 1013:
The value of a signal is not defined until after the design hierarchy is
elaborated. Use of the signal name in a declarative item is prohibited
because the value is undefined until the entire design has been
elaborated.
[DOC: IEEE Std 1076-1993 VHDL LRM - 12.3 Elaboration of a declarative part]


vcom Message # 1014:
When the expression is of an array type, the length of the array must
be known at compile time.  The simulator is less restrictive than the
LRM requires as long as the array length of the expression can be
determined in the compiler.
IEEE Std 1076-1993, 8.8 Case statement:

  If the expression is of a one-dimensional character array type, then
  the expression must be one of the following:
    -- The name of an object whose subtype is locally static
    -- An indexed name whose prefix is one of the members of this list
       and whose indexing expressions are locally static expressions
    -- A slice name whose prefix is one of the members of this list and
       whose discrete range is a locally static discrete range
    -- A function call whose return type mark denotes a locally static
       subtype
    -- A qualified expression or type conversion whose type mark
       denotes a locally static subtype

  It is an error if the element subtype of the one-dimensional character
  array type is not a locally static subtype.


vcom Message # 1015:
Array index values are limited to 32-bit integers. Computation of a
value has resulted in an overflow; that is, the value cannot be
contained in only 32 bits.


vcom Message # 1017:
The <entity>(<architecture>) portion of a +acc option design unit
specification has bad syntax or is missing an identifier.
[DOC: ModelSim Command Reference - vcom command]


vcom Message # 1018:
A illegal VHDL identifier was encountered.


vcom Message # 1019:
IEEE Std 1076-1993, 6.5 Slice names, line 193:
  The prefix of a slice must be appropriate for a one-dimensional
  array object.


vcom Message # 1020:
VHDL syntax requires exactly one formal part in an association element
when formal part is present.
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 433:
    association_element ::=
      [ formal_part => ] actual_part

    formal_part ::=
        formal_designator
      | function_name ( formal_designator )
      | type_mark ( formal_designator )


vcom Message # 1021:
IEEE Std 1076-1987, 4.3.3.2 Association Lists, page 4-11:
    formal_part ::=
        formal_designator
      | function_name ( formal_designator )

Syntax for the formal part does not allow a type conversion;
this capability was added for VHDL 1993.


vcom Message # 1022:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 435:
    formal_part ::=
        formal_designator
      | function_name ( formal_designator )
      | type_mark ( formal_designator )

IEEE Std 1076-1993, 4.3.2.2 Association lists, line 503:
  A formal [designator] may be either an explicitly declared interface
  object or member (see Section 3) of such an interface object.

IEEE Std 1076-1993, Section 3 Types, line 37:
  A member of an object is either
      -- A slice of the object
      -- A subelement of the object
      -- A slice of a subelement of the object.


vcom Message # 1023:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 459:
  Named associations can be given in any order, but if both positional
  and named associations appear in the same association list, then all
  positional associations must appear first and at their normal
  position. Hence once a named association is used, the rest of the
  association list must use only named associations.


vcom Message # 1024:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 508:
  Each association element that associates a slice or subelement
  (or slice thereof) of an interface object must identify the formal
  with a locally static name.


vcom Message # 1025:
IEEE Std 1076-1993, 5.2.1.2 Generic map and port map aspects, line 295:
  No scalar formal may be associated with more than one actual. No
  scalar subelement of any composite formal may be associated more than
  once in the same association list.
Similarly at lines 303 and 307.

IEEE Std 1076-1993, 7.3.3 Function calls, line 465:
  For each formal parameter of a function, a function call must specify
  exactly one corresponding actual parameter. This actual parameter is
  specified either explicitly, by an association element (other than the
  actual part OPEN) in the association list or, in the absence of such
  and association element, by a default expression (see 4.3.2).
Similarly in 8.6 Procedure call statement, line 381 for procedure calls.


vcom Message # 1026:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 503:
  A formal may be either an explicitly declared interface object or
  member (see Section 3) of such an interface object. In the former
  case, such a formal is said to be associated in whole. In the latter
  cases, named association must be used to associate the formal and
  actual; the subelements of such a formal are said to be associated
  individually. Furthermore, every scalar subelement of the explicitly
  declared interface object must be associated exactly once with an
  actual (or subelement thereof) in the same association list, and all
  such associations must appear in a contiguous sequence within that
  association list.


vcom Message # 1027:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 453:
  Each association element in an association list associates one actual
  designator with the corresponding interface element in the interface
  list of a subprogram declaration, component declaration, entity
  declaration, or block statement. The corresponding interface element
  is determined either by position or name.


vcom Message # 1028:
IEEE Std 1076-1993, 5.2.1.2 Generic map and port map aspects, line 295:
  No scalar formal may be associated with more than one actual. No
  scalar subelement of any composite formal may be associated more than
  once in the same association list.
Similarly at lines 303 and 307.

IEEE Std 1076-1993, 7.3.3 Function calls, line 465:
  For each formal parameter of a function, a function call must specify
  exactly one corresponding actual parameter. This actual parameter is
  specified either explicitly, by an association element (other than the
  actual part OPEN) in the association list or, in the absence of such
  and association element, by a default expression (see 4.3.2).
Similarly in 8.6 Procedure call statement, line 381 for procedure calls.


vcom Message # 1029:
IEEE Std 1076-1993, 6.5 Slice names, line 193:
  The prefix of a slice must be appropriate for a one-dimensional
  array object.


vcom Message # 1030:
IEEE Std 1076-1993, 2.1.1.2 Signal parameters, line 115:
  If an actual signal is associated with a signal parameter of any mode,
  and if the type of the formal is a scalar type, then it is an error if
  the bounds and direction of the subtype denoted by the subtype
  indication of the formal are not identical to the bounds and direction
  of the subtype denoted by the subtype indication of the actual.


vcom Message # 1031:
IEEE Std 1076-1993, 1.1.1.1 Generics, line 74:
  It is an error if no actual is specified for a given formal generic
  and no default expression is present in the corresponding interface
  element.


vcom Message # 1032:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 511:
  If an interface element in an interface list includes a default
  expression for a formal generic, for a formal port of any mode other
  than LINKAGE, or for a formal variable or constant parameter of mode
  IN, then any corresponding association list need not include an
  association element for that interface element. If the association
  element is not included, or if the actual OPEN is given, then the
  value of the default expression is used as the actual expression or
  signal value in an implicit association element for that interface
  element.


vcom Message # 1033:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 511:
  If an interface element in an interface list includes a default
  expression for a formal generic, for a formal port of any mode other
  than LINKAGE, or for a formal variable or constant parameter of mode
  IN, then any corresponding association list need not include an
  association element for that interface element. If the association
  element is not included, or if the actual OPEN is given, then the
  value of the default expression is used as the actual expression or
  signal value in an implicit association element for that interface
  element.


vcom Message # 1034:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 511:
  If an interface element in an interface list includes a default
  expression for a formal generic, for a formal port of any mode other
  than LINKAGE, or for a formal variable or constant parameter of mode
  IN, then any corresponding association list need not include an
  association element for that interface element. If the association
  element is not included, or if the actual OPEN is given, then the
  value of the default expression is used as the actual expression or
  signal value in an implicit association element for that interface
  element.


vcom Message # 1035:
IEEE Std 1076-1993, 1.1.1.2 Ports, line 112:
  A port of mode IN may be unconnected or unassociated (see 4.3.2.2)
  only if its declaration includes a default expression (see 4.3.2).


vcom Message # 1036:
IEEE Std 1076-1993, 1.1.1.2 Ports, line 113:
  A port of any mode other than IN may be unconnected or unassociated
  as long as its type is not an unconstrained array type.


vcom Message # 1037:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 511:
  If an interface element in an interface list includes a default
  expression for a formal generic, for a formal port of any mode other
  than LINKAGE, or for a formal variable or constant parameter of mode
  IN, then any corresponding association list need not include an
  association element for that interface element. If the association
  element is not included, or if the actual OPEN is given, then the
  value of the default expression is used as the actual expression or
  signal value in an implicit association element for that interface
  element.


vcom Message # 1038:
IEEE Std 1076-1987, 4.3.3.2 Association Lists:
The standard is not clear on whether or not it is valid to have the
formal part of a named association be in the form of a conversion
function call when the mode of the formal is IN. This is not supported
by vcom -87.

IEEE Std 1076-1993, 4.3.2.2 Association lists, line 463:
  The formal part of a named element association may be in the form of
  a function call, where the single argument of the function is the
  formal designator itself, if and only if the mode of the formal is
  OUT, INOUT, BUFFER, or LINKAGE, and if the actual is not OPEN.

IEEE Std 1076-2002, 4.3.2.2 Association lists, Page 67:
  The formal part of a named association element may be in the form of
  a function call, where the single argument of the function is the
  formal designator itself, if and only if the mode of the formal is
  OUT, INOUT, BUFFER, or LINKAGE, and if the actual is not OPEN.



vcom Message # 1039:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 468:
  [T]he formal part of a named element association may be in the form
  of a type conversion, where the expression to be converted is the
  formal designator itself, if and only if the mode of the formal is
  OUT, INOUT, BUFFER, or LINKAGE, and if the actual is not OPEN.

IEEE Std 1076-2002, 4.3.2.2 Association lists, Page 67:
  [T]he formal part of a named association element may be in the form
  of a type conversion, where the expression to be converted is the 
  formal designator itself, if and only if the mode of the formal is
  OUT, INOUT, BUFFER, or LINKAGE, and if the actual is not OPEN.


vcom Message # 1040:
IEEE Std 1076-1987, 4.3.3.2 Association Lists:
The standard is not clear on whether or not it is valid to have the
actual part of a (named or positional) association element be in the
form of a conversion function call when the mode of the associated
formal is OUT or BUFFER. This is not supported by vcom -87.

IEEE Std 1076-1993, 4.3.2.2 Association lists, line 474:
  [T]he actual part of a (named or positional) element association may
  be in the form of a function call, where the single argument of the
  function is the actual designator itself, if and only if the mode of
  the formal is IN, INOUT, or LINKAGE, and if the actual is not OPEN.

IEEE Std 1076-2002, 4.3.2.2 Association lists, Page 67:
  [T]he actual part of a (named or positional) association element may
  be in the form of a function call, where the single argument of the
  function is the actual designator itself, if and only if the mode of
  the formal is IN, INOUT, or LINKAGE, and if the actual is not OPEN.



vcom Message # 1041:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 481:
  [T]he actual part of a (named or positional) element association may
  be in the form of a type conversion, where the expression to be type
  converted is the actual designator itself, if and only if the mode of
  the formal is IN, INOUT, or LINKAGE, and if the actual is not OPEN.

IEEE Std 1076-2002, 4.3.2.2 Association lists, Page 67:
  [T]he actual part of a (named or positional) association element may
  be in the form of a type conversion, where the expression to be type
  converted is the actual designator itself, if and only if the mode of
  the formal is IN, INOUT, or LINKAGE, and if the actual is not OPEN.


vcom Message # 1042:
IEEE Std 1076-1993, 4.3.2.2 Association lists, lines 465 and 476:
  [T]he function name must denote a function whose single parameter
  is of the type of the [formal|actual] and whose result is the type of
  the corresponding [actual|formal].



vcom Message # 1043:
IEEE Std 1076-1993, 2.1.1.2 Signal parameters, line 113:
  It is an error if a conversion function or type conversion appears in
  either the formal part or the actual part of an association element
  that associates an actual signal with a formal signal parameter.



vcom Message # 1044:
IEEE Std 1076-1993, 2.1.1.2 Signal parameters, line 113:
  It is an error if a conversion function or type conversion appears in
  either the formal part or the actual part of an association element
  that associates an actual signal with a formal signal parameter.



vcom Message # 1045:
IEEE Std 1076-1987, 4.3.3.2 Association Lists --
The standard is not clear on when it is and is not valid to associate
OPEN with a formal. Associating OPEN with formal subelements that are
associated individually is not supported by vcom -87.

IEEE Std 1076-1993, 4.3.2.2 Association lists line 516:
  It is an error if an actual of OPEN is associated with a formal that
  is associated individually. An actual of OPEN counts as the single
  association allowed for the corresponding formal but does not supply
  a constant, signal, or variable (as is appropriate to the object
  class of the formal) to the formal.
EXAMPLE:
  Using the following association list as an example:
    ( OPEN, p1 => OPEN, p2(7 downto 0) => OPEN )
  For the associations "OPEN" and "p1 => OPEN", the formals are
  associated in whole; therefore the first two OPEN associations are
  legal whether the first formal and p1 are scalars or composites.
  For the association "p2(7 downto 0) => OPEN", the subelements of
  the formal are associated individually because of the slice
  specification; therefore the OPEN association is not legal even
  if the slice encompasses the entire range of p2.


vcom Message # 1046:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 516:
  It is an error if an actual of OPEN is associated with a formal that
  is associated individually. An actual of OPEN counts as the single
  association allowed for the corresponding formal but does not supply
  a constant, signal, or variable (as is appropriate to the object
  class of the formal) to the formal.
EXAMPLE:
  Using the following association list as an example:
    ( OPEN, p1 => OPEN, p2(7 downto 0) => OPEN )
  For the associations "OPEN" and "p1 => OPEN", the formals are
  associated in whole; therefore the first two OPEN association are
  legal whether the first formal and p1 are scalars or composites.
  For the association "p2(7 downto 0) => OPEN", the subelements of
  the formal are associated individually because of the slice
  specification; therefore the OPEN association is not legal even
  if the slice encompasses the entire range of p2.


vcom Message # 1047:
IEEE Std 1076-1993, 2.1.1 Formal parameters, line 48:
  In a subprogram call, the actual designator (see 4.3.2.2) associated
  with a formal parameter of class signal must be a signal. The actual
  designator associated with a formal of class variable must be a
  variable. The actual designator associated with a formal of class
  constant must be an expression. The actual designator associated with
  a formal of class file must be a file.


vcom Message # 1048:
IEEE Std 1076-1993, 7.3.2.2 Array aggregates, line 415:
  A named association of an array aggregate is allowed to have a choice
  that is not locally static, or likewise a choice that is a null range,
  only if the aggregate includes a single element association and this
  element association has a single choice. An OTHERS choice is locally
  static if the applicable index constraint is locally static.
We allow a non-locally static choice if the only other choice in the
aggregate is an OTHERS choice (locally static or not) in the last
association element.  Use the -pedanticerrors switch for strict VHDL
compliance to make this an error.


vcom Message # 1049:
The value of a signal is not defined until after the design hierarchy is
elaborated. Use of the signal name in a declarative item is prohibited
because the value is undefined.
[DOC: IEEE Std 1076-1993 VHDL LRM - 12.3 Elaboration of a declarative part]


vcom Message # 1050:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 463:
  The formal part of a named element association may be in the form of
  a function call, where the single argument of the function is the
  formal designator itself, if and only if the mode of the formal is
  OUT, INOUT, BUFFER, or LINKAGE, and if the actual is not OPEN.
  In this case, the function name must denote a function whose single
  parameter is of the type of the formal and whose result is the type
  of the corresponding actual.

IEEE Std 1076-1993, 4.3.2.2 Association lists, line 474:
  Similarly, the actual part of a (named or positional) element
  association may be in the form of a function call, where the single
  argument of the function is the actual designator itself, if and only
  if the mode of the formal is IN, INOUT, or LINKAGE, and if the actual
  is not OPEN. In this case, the function name must denote a function
  whose single parameter is of the type of the actual, and whose result
  is the type of the corresponding formal.  In addition, the formal must
  not be of class constant for this interpretation to hold (the actual
  is interpreted as an expression that is a function call if the class
  of the formal is constant).


vcom Message # 1051:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 463:
  The formal part of a named element association may be in the form of
  a function call, where the single argument of the function is the
  formal designator itself, if and only if the mode of the formal is
  OUT, INOUT, BUFFER, or LINKAGE, and if the actual is not OPEN.
  In this case, the function name must denote a function whose single
  parameter is of the type of the formal and whose result is the type
  of the corresponding actual.

IEEE Std 1076-1993, 4.3.2.2 Association lists, line 474:
  Similarly, the actual part of a (named or positional) element
  association may be in the form of a function call, where the single
  argument of the function is the actual designator itself, if and only
  if the mode of the formal is IN, INOUT, or LINKAGE, and if the actual
  is not OPEN. In this case, the function name must denote a function
  whose single parameter is of the type of the actual, and whose result
  is the type of the corresponding formal.  In addition, the formal must
  not be of class constant for this interpretation to hold (the actual
  is interpreted as an expression that is a function call if the class
  of the formal is constant).


vcom Message # 1052:
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 463:
  The formal part of a named element association may be in the form of
  a function call, where the single argument of the function is the
  formal designator itself, if and only if the mode of the formal is
  OUT, INOUT, BUFFER, or LINKAGE, and if the actual is not OPEN.
  In this case, the function name must denote a function whose single
  parameter is of the type of the formal and whose result is the type
  of the corresponding actual.

IEEE Std 1076-1993, 4.3.2.2 Association lists, line 474:
  Similarly, the actual part of a (named or positional) element
  association may be in the form of a function call, where the single
  argument of the function is the actual designator itself, if and only
  if the mode of the formal is IN, INOUT, or LINKAGE, and if the actual
  is not OPEN. In this case, the function name must denote a function
  whose single parameter is of the type of the actual, and whose result
  is the type of the corresponding formal.  In addition, the formal must
  not be of class constant for this interpretation to hold (the actual
  is interpreted as an expression that is a function call if the class
  of the formal is constant).


vcom Message # 1053:
IEEE Std 1076-1993, 12.6.2 Propagation of signal values, line 498:
  The driving value of a formal part is obtained by evaluating the
  formal part as follows:  If no conversion function or type conversion
  is present in the formal part, then the driving value of the formal
  part is the driving value of the signal denoted by the formal
  designator.  Otherwise, the driving value of the formal part is the
  value obtained by applying either the conversion function or type
  conversion (whichever is contained in the formal part) to the driving
  value of the signal denoted by the formal designator.

This necessitates that the FUNCTION used as a conversion function in the
formal part of an association element have a class constant formal
parameter as its (single) formal parameter because otherwise (with a
formal parameter of class signal) there could be no guarantee that only
the driving value of the signal denoted by the formal designator was
being used.


vcom Message # 1054:
IEEE Std 1076-1993, 12.6.2 Propagation of signal values, line 521:
  If S is a connected port of mode IN or INOUT, then the effective
  value of S is the same as the effective value of the actual part
  of the association element that associates an actual with S (see
  4.3.2.2). The effective value of an actual part is obtained by
  evaluating the actual part, using the effective value of the signal
  denoted by the actual designator in place of the actual designator.

This necessitates that the FUNCTION used as a conversion function in the
actual part of an association element have a class constant formal
parameter as its (single) formal parameter because otherwise (with a
formal parameter of class signal) there could be no guarantee that only
the effective value of the signal denoted by the actual designator was
being used.


vcom Message # 1060:
IEEE Std 1076-1993, 7.3.2 Aggregates, line 389:
  An element association with the choice OTHERS is allowed in either
  an array aggregate or a record aggregate if the association appears
  last and has this single choice; it specifies all remaining elements,
  if any.


vcom Message # 1061:
IEEE Std 1076-1993, 7.3.2 Aggregates, line 389:
  An element association with the choice OTHERS is allowed in either
  an array aggregate or a record aggregate if the association appears
  last and has this single choice; it specifies all remaining elements,
  if any.


vcom Message # 1062:
IEEE Std 1076-1993, 7.3.2 Aggregates, line 380:
  Both named and positional associations can be used in the same
  aggregate, with all positional associations appearing first (in
  textual order) and all named associations appearing next (in any
  order, except that no associations may follow an OTHERS association).


vcom Message # 1063:
Each element of the value defined by an aggregate must be represented
once and only once in the aggregate.
[DOC: IEEE Std 1076-1993 VHDL LRM - 7.3.2 Aggregates]


vcom Message # 1064:
If the choice OTHERS is given as a choice of a record aggregate, it must
represent at least one element.
[DOC: IEEE Std 1076-1993 VHDL LRM - 7.3.2.1 Record aggregates]


vcom Message # 1065:
The record element name specified in a choice of an element association
in a record aggregate does not have a corresponding record element in
the record type.


vcom Message # 1066:
IEEE Std 1076-1993, 7.3.2 Aggregates, line 392:
  Each element of the value defined by an aggregate must be represented
  once and only once in the aggregate.


vcom Message # 1067:
A choice in a named element association of an aggregate of a record
type must be either an element simple name or the reserved word OTHERS.
[DOC: IEEE Std 1076-1993 VHDL LRM - 7.3.2 Aggregates]


vcom Message # 1068:
IEEE Std 1076-1993, 3.2.1 Array types, line 286:
  The name for an element of an array uses one or more index values
  belonging to specified discrete types.

IEEE Std 1076-1993, 7.3.2.2 Array aggregates, line 407:
  For an aggregate of a one-dimensional array type, each choice must
  specify values of the index type[.]


vcom Message # 1069:
IEEE Std 1076-1993, 7.3.2.2 Array aggregates, line 414:
  Apart from a final element association with the single choice OTHERS,
  the rest (if any) of the element associations of an array aggregate
  must be either all positional or all named.


vcom Message # 1070:
A choice must be of the same type as the index subtype of the base
array type.  Since the bounds are not the same type, at least one
of them is not of the same type as the index subtype.
[DOC: IEEE Std 1076-1993 VHDL LRM - 7.3.2.2 Array aggregates]


vcom Message # 1071:
A choice must be of the same type as the index subtype of the base
array type.
[DOC: IEEE Std 1076-1993 VHDL LRM - 7.3.2.2 Array aggregates]


vcom Message # 1072:
IEEE Std 1076-1993, 7.3.2.2 Array aggregates, line 415:
  A named association of an array aggregate is allowed to have a choice
  that is not locally static, or likewise a choice that is a null range,
  only if the aggregate includes a single element association and this
  element association has a single choice. An OTHERS choice is locally
  static if the applicable index constraint is locally static.


vcom Message # 1073:
IEEE Std 1076-1993, 7.3.2.2 Array aggregates, line 415:
  A named association of an array aggregate is allowed to have a choice
  that is not locally static, or likewise a choice that is a null range,
  only if the aggregate includes a single element association and this
  element association has a single choice. An OTHERS choice is locally
  static if the applicable index constraint is locally static.
We allow a non-locally static choice if the only other choice in the
aggregate is an OTHERS choice (locally static or not) in the last
association element.  Use the -pedanticerrors switch for strict VHDL
compliance to make this an error.


vcom Message # 1074:
IEEE Std 1076-1993, 7.3.2.2 Array aggregates, line 415:
  A named association of an array aggregate is allowed to have a choice
  that is not locally static, or likewise a choice that is a null range,
  only if the aggregate includes a single element association and this
  element association has a single choice. An OTHERS choice is locally
  static if the applicable index constraint is locally static.
ModelSim allows a non-locally static OTHERS choice if all the other
element associations are positional associations, or if all the other
choices in named associations are locally static, or if there only one
other non-locally static choice.  Use the -pedanticerrors switch for
strict VHDL compliance to make this an error.


vcom Message # 1075:
IEEE Std 1076-1993, 7.3.2 Aggregates, line 392:
  Each element of the value defined by an aggregate must be represented
  once and only once in the aggregate.


vcom Message # 1076:
IEEE Std 1076-2002, 7.3.2.2 Array aggregates, page 109:
  The subtype of an array aggregate that has an OTHERS choice must be
  determinable from the context. That is, an array aggregate with an
  OTHERS choice must appear only in one of the following contexts:

    a) As an actual associated with a formal parameter or formal generic
       declared to be of a constrained array subtype (or subelement
       thereof)

    b) As the default expression defining the default initial value of a
       port declared to be of a constrained array subtype

    c) As the result expression of a function, where the corresponding
       function result type is a constrained array subtype

    d) As a value expression in an assignment statement, where the
       target is a declared object, and the subtype of the target is a
       constrained array subtype (or subelement of such a declared
       object)

    e) As the expression defining the initial value of a constant or
       variable object, where that object is declared to be of a
       constrained array subtype

    f) As the expression defining the default values of signals in a
       signal declaration, where the corresponding subtype is a
       constrained array subtype

    g) As the expression defining the value of an attribute in an
       attribute specification, where that attribute is declared to be of
       a constrained array subtype

    h) As the operand of a qualified expression whose type mark denotes
       a constrained array subtype

    i) As a subaggregate nested within an aggregate, where that aggregate
       itself appears in one of these contexts


vcom Message # 1077:
In a type conversion between array types, a check is made that any
constraint on the element subtype is the same for the operand array type
as for the target array type.
For an element subtype that is a scalar subtype, the bounds of
the range constraint must match those of the subtype of the operand.
For an element subtype that is an array subtype, the bounds of
each index range in the index constraint must match those of the
operand.
[DOC: IEEE Std 1076-1993 VHDL LRM - 7.3.5 Type conversions]
Allowed if target type element constraint is a superset of the operand
type element constraint.


vcom Message # 1078:
The name is ambiguous according to the visibility rules.
IEEE Std 1076-1993, 10.4 Use clauses, line 234:
  Potentially visible declarations that have the same designator are not
  made directly visible unless each of them is either an enumeration
  literal specification or the declaration of a subprogram (either by a
  subprogram declaration or by an implicit declaration).



vcom Message # 1079:
The left and right bounds of a range expression (of the form
simple_expression direction simple_expression) must either
have the same type, or either both be of some integer type or
both be of some floating point type.
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.1.2 Integer types]
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.1.3 Physical types]
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.1.4 Floating point types]


vcom Message # 1080:
For a discrete range used in a constrained array definition and defined
by a range, an implicit conversion to the predefined type INTEGER is
assumed if each bound is either a numeric literal or an attribute, and
if the type of both bounds (prior to the implicit conversion) is the
type universal_integer.
Otherwise, both bounds must be of the same discrete type, other than
universal_integer; this type must be determined independently of the
context, but using the fact that the type must be discrete and that
both bounds must have the same type. These rules also apply to a
discrete range used in an iteration scheme (see 8.9) or a generation
scheme (see 9.7).
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.2.1.1. Index constraints and discrete ranges]


vcom Message # 1081:
For a discrete range used in a constrained array definition and defined
by a range, an implicit conversion to the predefined type INTEGER is
assumed if each bound is either a numeric literal or an attribute, and
if the type of both bounds (prior to the implicit conversion) is the
type universal_integer.
Otherwise, both bounds must be of the same discrete type, other than
universal_integer; this type must be determined independently of the
context, but using the fact that the type must be discrete and that
both bounds must have the same type. These rules also apply to a
discrete range used in an iteration scheme (see 8.9) or a generation
scheme (see 9.7).
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.2.1.1. Index constraints and discrete ranges]


vcom Message # 1082:
For a discrete range used in a constrained array definition and defined
by a range, an implicit conversion to the predefined type INTEGER is
assumed if each bound is either a numeric literal or an attribute, and
if the type of both bounds (prior to the implicit conversion) is the
type universal_integer.
Otherwise, both bounds must be of the same discrete type, other than
universal_integer; this type must be determined independently of the
context, but using the fact that the type must be discrete and that
both bounds must have the same type. These rules also apply to a 
discrete range used in an iteration scheme (see 8.9) or a generation
scheme (see 9.7).
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.2.1.1. Index constraints and discrete ranges]


vcom Message # 1083:
The implicit operator "=" (likewise "/=") will return FALSE
(likewise TRUE) if the operands have different array index range
lengths at any position in the index constraint.


vcom Message # 1084:
If a range constraint is used in a subtype indication, the type of the
expressions (likewise, of the bounds of a range attribute) must be the
same as the base type of the type mark of the subtype indication.
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.1 Scalar types]


vcom Message # 1085:
If a range constraint is used in a subtype indication, the type of the
expressions (likewise, of the bounds of a range attribute) must be the
same as the base type of the type mark of the subtype indication.
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.1 Scalar types]


vcom Message # 1086:
The bounds of the discrete range define those of the slice and must be
of the type of the index of the array.
[DOC: IEEE Std 1076-1993 VHDL LRM - 6.5 Slice names]


vcom Message # 1087:
The bounds of the discrete range define those of the slice and must be
of the type of the index of the array.
[DOC: IEEE Std 1076-1993 VHDL LRM - 6.5 Slice names]


vcom Message # 1088:
Index expression(s) of an indexed name can not be range(s).
[DOC: IEEE Std 1076-1993 VHDL LRM - 6.4 Indexed names]


vcom Message # 1089:
A slice name denotes a one-dimensional array composed of a sequence of
consecutive elements of another one-dimensional array. The prefix must
be of a one-dimensional array type, and there must be exactly one
discrete range.
[DOC: IEEE Std 1076-1993 VHDL LRM - 6.5 Slice names]


vcom Message # 1090:
A process that has no sensitivity list, contains no wait statements,
and contains no calls to procedures that contain wait statements will
execute forever without advancing time.

IEEE Std 1076-2002, 9.2 Process statement:
  The execution of a process statement consists of the repetitive
  execution of its sequence of statements. After the last statement in
  the sequence of statements of a process statement is executed,
  execution will immediately continue with the first statement in the
  sequence of statements.

This message is controlled by the vcom option -nowarn 2.


vcom Message # 1091:
The keyword POSTPONED must not appear at the end of a process that does
not start with the keyword POSTPONED.

IEEE Std 1076-2002, 9.2 Process statement:

  If the reserved word POSTPONED precedes the initial reserved word
  PROCESS, the process statement defines a postponed process; otherwise,
  the process statement defines a nonpostponed process.

  If the reserved word POSTPONED appears at the end of a process
  statement, the process must be a postponed process.


vcom Message # 1092:
Signals in process sensitivity lists must be static.
IEEE Std 1076-2002, 9.2 Process statement:
  It is an error if any name that does not denote a static signal name
  (see 6.1) for which reading is permitted appears in the sensitivity
  list of a process statement.


vcom Message # 1093:
EXIT and NEXT statements cannot appear outside of a LOOP statement.

IEEE Std 1076-2002, 8.10 Next statement:

  A next statement is used to complete the execution of one of the
  iterations of an enclosing loop statement (called "loop" in the
  following text).

  A next statement with a loop label is only allowed within the labeled
  loop and applies to that loop; a next statement without a loop label
  is only allowed within a loop and applies only to the innermost
  enclosing loop (whether labeled or not).

IEEE Std 1076-2002, 8.11 Exit statement:

  An exit statement is used to complete the execution of an enclosing
  loop statement (called "loop" in the following text).

  An exit statement with a loop label is only allowed within the labeled
  loop and applies to that loop; an exit statement without a loop label
  is only allowed within a loop and applies only to the innermost
  enclosing loop (whether labeled or not).


vcom Message # 1094:
When a label is specified with an EXIT or NEXT statement, it must be the
label of a LOOP statement.

IEEE Std 1076-2002, 8.10 Next statement:

  A next statement with a loop label is only allowed within the labeled
  loop and applies to that loop; a next statement without a loop label
  is only allowed within a loop and applies only to the innermost
  enclosing loop (whether labeled or not).

IEEE Std 1076-2002, 8.11 Exit statement:

  An exit statement with a loop label is only allowed within the labeled
  loop and applies to that loop; an exit statement without a loop label
  is only allowed within a loop and applies only to the innermost
  enclosing loop (whether labeled or not).


vcom Message # 1095:
When a label is specified with an EXIT or NEXT statement, the EXIT or
NEXT statement must be inside of the specified LOOP statement.

IEEE Std 1076-2002, 8.10 Next statement:

  A next statement with a loop label is only allowed within the labeled
  loop and applies to that loop; a next statement without a loop label
  is only allowed within a loop and applies only to the innermost
  enclosing loop (whether labeled or not).

IEEE Std 1076-2002, 8.11 Exit statement:

  An exit statement with a loop label is only allowed within the labeled
  loop and applies to that loop; an exit statement without a loop label
  is only allowed within a loop and applies only to the innermost
  enclosing loop (whether labeled or not).


vcom Message # 1096:
The specified name was referenced as a label but was not found to be a
label of any statement. A name referenced as a label name must be the name
of a label on a statement appropriate to the reference.


vcom Message # 1097:
VHDL 1987 does not allow an operator as an alias.
Use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1098:
VHDL 1987 does not allow a character as an alias.
Use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1099:
VHDL 1987 does not allow signatures.
Use VHDL93 or later (vcom options -93, -2002, etc.).


vcom Message # 1100:
VHDL 1987 does not allow END ARCHITECTURE.
Remove ARCHITECTURE or use VHDL 1993 or later.


vcom Message # 1101:
Use VHDL93 or later (vcom options -93, -2002, etc.).


vcom Message # 1102:
An element association with the choice OTHERS is allowed in either an
array aggregate or a record aggregate if the association appears last
and has this single choice.
[DOC: IEEE std 1076-2002 VHDL LRM - 7.3.2 Aggregates]


vcom Message # 1103:
Use VHDL93 or later (vcom options -93, -2002, etc.).


vcom Message # 1104:
VHDL 1987 does not allow END CONFIGURATION.
Remove CONFIGURATION or use VHDL93 or later (vcom options -93, -2002, etc.).


vcom Message # 1105:
There must be an entity name here.


vcom Message # 1106:
There must be a configuration here.


vcom Message # 1107:
Use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1108:
Use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1109:
Use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1110:
Use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1111:
Remove ENTITY or use VHDL93 or later (vcom options -93, -2002, etc.).


vcom Message # 1112:
 Recompile using VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1113:
Use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1114:
Use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1115:
Index constraints are not allowed on the return type.


vcom Message # 1116:
VHDL 1987 does not allow END PACKAGE BODY. Remove PACKAGE BODY or use
VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1117:
VHDL 1987 does not allow END PACKAGE. Remove PACKAGE or use
VHDL93 or later (vcom options -93, -2002, etc.).


vcom Message # 1118:
In VHDL 1987 functions must call pure subprograms.

vcom Message # 1119:
A pure function must not call an impure subprogram.

vcom Message # 1120:
Several places in VHDL that allow subtype indications do not allow the
subtype indication to specify a resolution function. These places are:
 1) As part of an allocator
   [DOC: IEEE Std 1076-2002 VHDL LRM - 7.3.6 Allocators]
 2) As part of the access type declaration
   [DOC: IEEE Std 1076-2002 VHDL LRM - 3.3 Access types]


vcom Message # 1121:
A range constraint in a type definition must be locally static.
[DOC: IEEE Std 1076-2002 VHDL LRM - 3.1.2 Integer types]
[DOC: IEEE Std 1076-2002 VHDL LRM - 3.1.3 Physical types]
[DOC: IEEE Std 1076-2002 VHDL LRM - 3.1.4 Floating point types]


vcom Message # 1122:
Remove the name or label or use VHDL 1993 or later
(vcom options -93, -2002, etc.).


vcom Message # 1123:
Remove IS or use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1124:
Remove BEGIN or use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1125:
VHDL 1987 does not allow END PROCEDURE. Remove PROCEDURE or use VHDL 1993
or later (vcom options -93, -2002, etc.).


vcom Message # 1126:
VHDL 1987 does not allow END FUNCTION. Remove FUNCTION or use VHDL 1993
or later (vcom options -93, -2002, etc.).


vcom Message # 1127:
While attempting to find a default binding for an instance that was not
specifically bound, a matching entity was found but not used because it
is out of date relative to at least one of it dependencies and needs to
be recompiled.
The warning version of this message can be suppressed with the vcom
option -nowarn 1.


vcom Message # 1128:
In generate statements, declarative items must be separated from concurrent
statements by the keyword BEGIN.


vcom Message # 1129:
While attempting to bind a component to an entity, the type of the
specified generic in the component declaration was found to be different
than the matching formal generic of the specified entity. This message
will be displayed as a warning if the entity is being chosen for a
default binding. If the default binding is overridden later by a
specific binding, then this warning can be ignored. Otherwise, this
will cause an elaboration error.
The warning version of this message can be suppressed with the vcom
option -nowarn 1.


vcom Message # 1130:
An entity formal port must have a corresponding port declared in the
component declaration that is bound to the entity if the port is either:
 a) of mode IN and does not have a default expression, or
 b) of any other mode and is of an unconstrained array type.
This message will be displayed as a warning if the entity is being
chosen for a default binding. If the default binding is overridden
later by a specific binding, then this warning can be ignored.
Otherwise, this will cause an elaboration error.
The warning version of this message can be suppressed with the
vcom option -nowarn 1.


vcom Message # 1131:
The specified port is declared in the specified component declaration
but the port has no corresponding formal port in the specified entity.
This message will be displayed as a warning if the entity is being
chosen for a default binding. If the default binding is overridden
later by a specific binding, then this warning can be ignored.
Otherwise, this will cause an elaboration error.
The warning version of this message can be suppressed with the
vcom option -nowarn 1.


vcom Message # 1132:
The specified port in the specified component declaration is not associated
with anything in the port map.
[DOC: IEEE Std 1076-2002 VHDL LRM - 5.2.1.2 Generic map and port map aspects]


vcom Message # 1133:
While attempting to bind a component to an entity, the type of the
specified port in the component declaration was found to be different
than the matching formal port of the specified entity. This message
will be displayed as a warning if the entity is being chosen for a
default binding. If the default binding is overridden later by a
specific binding, then this warning can be ignored. Otherwise, this
will cause an elaboration error.
The warning version of this message can be suppressed with the
vcom option -nowarn 1.


vcom Message # 1134:
While attempting to bind a component to an entity, the mode of the
specified port in the component declaration was found to be incompatible
with the matching formal port of the specified entity. Compatible port
modes are as follows:

  Formal Port Mode      Actual Port Mode
  ----------------      ----------------
  IN                    IN, INOUT, BUFFER
  OUT                   OUT, INOUT (BUFFER - VHDL 2002 and Verilog only)
  INOUT                 INOUT (BUFFER - VHDL2002 only)
  BUFFER                BUFFER (OUT and INOUT - VHDL 2002 only)
  LINKAGE               any mode

This message may be displayed as a warning if the entity is being chosen
for a default binding. If the default binding is overridden later by a
specific binding, then this warning can be ignored. Otherwise, this is an
elaboration error.
The warning version of this message can be suppressed with the
vcom option -nowarn 1.
[DOC: IEEE Std 1076-2002 VHDL LRM - 1.1.1.2 Ports]


vcom Message # 1135:
The syntax for declaring subprogram parameters that are files changed
from the 1987 to the 1993 version of the VHDL language. File parameters
must have the keyword FILE before their declaration.


vcom Message # 1136:
The specified name was referenced but was not found. This indicates
that either the name specified does not exist or is not visible at this
point in the code.


vcom Message # 1137:
The expression did not satisfy the requirements for a CASE expression
or a selected signal assignment expression of an array type.
IEEE Std 1076-1993, 8.8 Case statement:

  If the expression is of a one-dimensional character array type, then
  the expression must be one of the following:
    -- The name of an object whose subtype is locally static
    -- An indexed name whose prefix is one of the members of this list
       and whose indexing expressions are locally static expressions
    -- A slice name whose prefix is one of the members of this list and
       whose discrete range is a locally static discrete range
    -- A function call whose return type mark denotes a locally static
       subtype
    -- A qualified expression or type conversion whose type mark
       denotes a locally static subtype

  It is an error if the element subtype of the one-dimensional character
  array type is not a locally static subtype.


vcom Message # 1138:
Attributes must be declared with an attribute declaration before use
in an attribute specification.


vcom Message # 1139:
The identifier did not denote the name of an attribute.


vcom Message # 1140:
The 1993 version of VHDL standardized on the attribute FOREIGN for
foreign subprograms and design units. As a result, a declaration
of the attribute FOREIGN was added to the standard package.
If another package declares the attribute FOREIGN and is included via
a USE clause, both definitions of the attribute should be hidden.
For upward compatibility the attribute declaration from the standard
package is being used.
Use the -pedanticerrors option to force strict language compliance.


vcom Message # 1141:
The identifier used here must refer to a visible component declaration.


vcom Message # 1142:
The type of the actual designator associated with the formal port of a
Verilog module is either not a supported type, or could not be
determined.  When the type cannot be determined, it is usually because
the subelements of an individually associated formal are not all of the
same type, making determining the array type impossible.


vcom Message # 1143:
The expression is legal under VHDL-1987 but ambiguous under VHDL-1993
semantics. Either use qualified expressions for the types of parameters
or compile using VHDL-1987.


vcom Message # 1144:
The value does not belong to the range defined by the range constraint
of the scalar subtype.


vcom Message # 1145:
The value does not belong to the range defined by the range constraint
of the scalar subtype.


vcom Message # 1146:
No value can belong to a null range constraint of a scalar subtype.


vcom Message # 1147:
The range in the FOR loop of a GENERATE must not depend on a signal or
other non-static value.

vcom Message # 1148:
The condition in an IF condition of a GENERATE must not depend on a signal
or other non-static value.

vcom Message # 1149:
The parameter value of the specified predefined attribute is outside
the range of the type of the prefix.
[DOC: IEEE Std 1076-1993 VHDL LRM - 14.1 Predefined attributes]


vcom Message # 1150:
The parameter value of the specified predefined attribute is an
illegal value; the attribute cannot return a legal value given
this parameter as input.
[DOC: IEEE Std 1076-1993 VHDL LRM - 14.1 Predefined attributes]


vcom Message # 1151:
The result of the specified predefined attribute is outside
the range of the type of the prefix.
[DOC: IEEE Std 1076-1993 VHDL LRM - 14.1 Predefined attributes]


vcom Message # 1152:
The index value must belong to both the index subtype of the base array
type and the index range of the constrained array subtype.


vcom Message # 1153:
The index value must belong to both the index subtype of the base array
type and the index range of the constrained array subtype.


vcom Message # 1154:
The index value must belong to both the index subtype of the base array
type and the index range of the constrained array subtype.  This is
impossible when the range is a null range because no value can belong
to a null range.


vcom Message # 1155:
When using a default binding, a formal port on the entity to which a
component declaration is bound was not declared in the component.
This is an error only if the port is of mode IN and does not have a
default expression, or if the port is of an unconstrained array type.
This message is for informational purposes only (-lint) and there is
no LRM violation or potential violation.


vcom Message # 1156:
The result of the concatenation would have an array index range whose
right bound would not belong to the index subtype of the base type
of the array.


vcom Message # 1157:
The array index right bound does not belong to the index subtype of
the base type of the array at this index position.  The length of the
array at this index position is too large to be represented by this
array type.


vcom Message # 1158:
Exponentiation is defined as repeated multiplication of the left
operand by itself for a number of times indicated by the absolute value
of the right operand.  This operation has resulted in a number too
large in absolute value to be represented within the limits of the
implementation.


vcom Message # 1159:
Exponentiation with a negative exponent is allowed only for a left
operand of a floating point type.
[DOC: IEEE Std 1076-2002 VHDL LRM - 7.2.7 Miscellaneous operators]


vcom Message # 1160:
The evaluation of a qualified expression evaluates the operand and
checks that its value belongs to the subtype denoted by the type mark.
For array subtypes this means that at each position in the index
constraint, the index ranges must match.
[DOC: IEEE Std 1076-1993 VHDL LRM - 7.3.4 Qualified expressions]


vcom Message # 1161:
IEEE Std 1076-1993, 2.1.1.2 Signal parameters, line 115:
  If an actual signal is associated with a signal parameter of any mode,
  and if the type of the formal is a scalar type, then it is an error if
  the bounds and direction of the subtype denoted by the subtype
  indication of the formal are not identical to the bounds and direction
  of the subtype denoted by the subtype indication of the actual.


vcom Message # 1162:
An expression can not be used as the actual expression for a formal
that is not of mode IN.


vcom Message # 1163:
A Verilog module having a port with a range that depends on a parameter
results in an equivalent VHDL entity (for the purposes of instantiating
Verilog in VHDL) with a port of an unconstrained array type.  If the
port map of the VHDL instance of the Verilog module either has
individual associations or is an array aggregate or string literal
expression, then the array length and/or direction might not match
those of the elaborated Verilog port when the design is loaded,
possibly causing a bit-wise reversal of the actual value.  For all the
array types supported at the VHDL-Verilog boundary, the Verilog port
will be assumed to have a direction of TO because the VHDL rules for
determining the index range of an unconstrained array formal
that is associated individually state that the direction is that of
the index subtype of the array, which is the predefined subtype NATURAL.
Use a component instantiation where the component port is of a
constrained array subtype with the same length and direction as the
corresponding elaborated Verilog module port's range.


vcom Message # 1164:
Impure function calls are not globally static expressions and
the actual of a port connection, if an expression, must be a
globally static expression.


vcom Message # 1165:
IEEE Std 1076-1993, 4.3.3.1 Object aliases, line 573:
  If the subtype indication denotes a scalar subtype, then the object
  is viewed as if it were of the subtype specified by the subtype
  indication; moreover, it is an error if this subtype does not have
  the same bounds and direction as the subtype denoted by the object
  name.


vcom Message # 1166:
IEEE Std 1076-1993, 7.3.6 Allocators, line 545:
  The only allowed form of constraint in the subtype indication of an
  allocator is an index constraint.


vcom Message # 1167:
The index value must belong to both the index subtype of the base array
type and the index range of the constrained array subtype.


vcom Message # 1168:
The index value must belong to both the index subtype of the base array
type and the index range of the constrained array subtype.


vcom Message # 1169:
The index constraint must provide a discrete range for each index of
the array type, and the type of each discrete range must be the same as
that of the corresponding index.
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.2.1.1 Index constraints and discrete ranges]


vcom Message # 1170:
The index constraint must provide a discrete range for each index of
the array type, and the type of each discrete range must be the same as
that of the corresponding index.
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.2.1.1 Index constraints and discrete ranges]


vcom Message # 1171:
The predefined attribute 'DRIVING requires that its prefix signal
have a driver present in the process in which it appears.
The predefined attribute 'DRIVING_VALUE requires that the value of
'DRIVING not be FALSE at the point of evaluation; this implies that
'DRIVING be evaluatable, hence it is an error if no drivers are present.
[DOC: IEEE Std 1076-1993 VHDL LRM - 14.1 Predefined attributes]


vcom Message # 1172:
The rules for multi-dimensional array aggregates require that each
element representing a subaggregate be either another aggregate or a
string literal or bit string literal.  Because sub-arrays of
multi-dimensional array types have no type, there is no type with
which to resolve the element expression, and no implicit type conversion
occurs.  ModelSim will perform this type conversion if possible however.
Use the -pedanticerrors switch to enforce strict LRM compliance and make
this an error.
[DOC: IEEE Std 1076-1993 VHDL LRM - 7.3.2.2 Array aggregates]


vcom Message # 1173:
In a type conversion between array types, a check is made that any
constraint on the element subtype is the same for the operand array type
as for the target array type.
For an element subtype that is a scalar subtype, the bounds of
the range constraint must match those of the subtype of the operand.
For an element subtype that is an array subtype, the bounds of
each index range in the index constraint must match those of the
operand.
[DOC: IEEE Std 1076-1993 VHDL LRM - 7.3.5 Type conversions]


vcom Message # 1174:
IEEE Std 1076-1993, 7.3.2 Aggregates, line 392:
  Each element of the value defined by an aggregate must be represented
  once and only once in the aggregate.


vcom Message # 1175:
IEEE Std 1076-1993, 10.3 Visibility, line 143:
  Within the specification of a subprogram, every declaration with the
  same designator as the subprogram is hidden.  Where hidden in this
  manner, a declaration is visible neither by selection nor directly.


vcom Message # 1176:
The VHDL 1987 language requires that a subtype indication be present in
the declaration of an alias.
[DOC: IEEE Std 1076-1987 VHDL LRM - 4.3.4 Alias Declaration]


vcom Message # 1177:
VHDL syntax requires that the target type in a type conversion
expression be a type mark, which is just a simple type or subtype name
with no constraint (or resolution function either).


vcom Message # 1178:
VHDL syntax requires that a qualified expression type be a type_mark,
which is just a simple type or subtype name with no constraint (or
resolution function either).


vcom Message # 1179:
An individual association element whose formal designator is a slice
of the formal has a slice discrete range with a direction different
from the direction of the formal itself.
The slice is a null slice if the direction of the discrete range is not
the same as that of the object denoted by the prefix of the slice name.
[DOC: IEEE Std 1076-1987 VHDL LRM - 6.5 Slice names]
This was changed to an error in VHDL 1993, see message #1181.


vcom Message # 1180:
It is impossible to create a null slice (see warning message #1179) when
the bounds of the discrete range are identical.


vcom Message # 1181:
An individual association element whose formal designator is a slice
of the formal has a slice discrete range with a direction different
from the direction of the formal itself.
It is an error if the direction of the discrete range of a slice name
is not the same as that of the index range of the array denoted by the
prefix of the slice name.
[DOC: IEEE Std 1076-1993 VHDL LRM - 6.5 Slice names]


vcom Message # 1182:
The array index values given in the individual association elements
corresponding to the formal do not form a complete uninterrupted set
of values needed to form an association for every subelement of the
formal.
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 506:
  Furthermore, every scalar subelement of the explicitly declared
  interface object must be associated exactly once with an actual (or
  subelement thereof) in the same association list, and all such
  associations must appear in a contiguous sequence within that
  association list.


vcom Message # 1183:
A component instantiation label in the component specification of a
component configuration is a duplicate of such a label found in the
component specification of a configuration specification.
IEEE Std 1076-1993, 5.2 Configuration specification, line 146:
  It is an error if the elaboration of a configuration specification
  results in the association of binding information with a component
  label that is already bound.


vcom Message # 1184:
The ALL instantiation list of the component specification of a
component configuration is associating binding information
with a component instance that has already been bound in a
configuration specification.
IEEE Std 1076-1993, 5.2 Configuration specification, line 146:
  It is an error if the elaboration of a configuration specification
  results in the association of binding information with a component
  label that is already bound.


vcom Message # 1185:
A component instantiation label in the component specification of
a configuration specification is a duplicate of such a label found in a
preceding configuration specification.
IEEE Std 1076-1993, 5.2 Configuration specification, line 146:
  It is an error if the elaboration of a configuration specification
  results in the association of binding information with a component
  label that is already bound.


vcom Message # 1186:
When the expression is of an array type, the length of the array must
be known at compile time.  The simulator is less restrictive than the
LRM requires as long as the array length of the expression can be
determined in the compiler.
IEEE Std 1076-1993, 8.8 Case statement:

  If the expression is of a one-dimensional character array type, then
  the expression must be one of the following:
    -- The name of an object whose subtype is locally static
    -- An indexed name whose prefix is one of the members of this list
       and whose indexing expressions are locally static expressions
    -- A slice name whose prefix is one of the members of this list and
       whose discrete range is a locally static discrete range
    -- A function call whose return type mark denotes a locally static
       subtype
    -- A qualified expression or type conversion whose type mark
       denotes a locally static subtype

  It is an error if the element subtype of the one-dimensional character
  array type is not a locally static subtype.


vcom Message # 1187:
A composite type (array or record) may only contain elements that are
of scalar, composite, or access types; elements of file types are not
allowed in a composite type.
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.2 Composite types]


vcom Message # 1188:
IEEE Std 1076-1993, 3.2.1.1 Index constraints and discrete ranges, line 410:
  If the index ranges for an interface object or member of an interface
  object are obtained from the corresponding association element, then
  they are determined either by the actual part or by the formal part
  of the association element, depending on the mode of the interface
  object, as follows:
IEEE Std 1076-1993, 3.2.1.1 Index constraints and discrete ranges, line 419:
  For an interface object or member of an interface object whose mode
  is OUT, BUFFER, INOUT, or LINKAGE, if the formal part includes a
  conversion function or a type conversion, then the parameter subtype
  of that function or the type mark of the type conversion must be a
  constrained array subtype, and the index ranges are obtained from
  this constrained subtype; otherwise, the index ranges are obtained
  from the object denoted by the actual designator.


vcom Message # 1189:
IEEE Std 1076-1993, 3.2.1.1 Index constraints and discrete ranges, line 410:
  If the index ranges for an interface object or member of an interface
  object are obtained from the corresponding association element, then
  they are determined either by the actual part or by the formal part
  of the association element, depending on the mode of the interface
  object, as follows:
IEEE Std 1076-1993, 3.2.1.1 Index constraints and discrete ranges, line 419:
  For an interface object or member of an interface object whose mode
  is OUT, BUFFER, INOUT, or LINKAGE, if the formal part includes a
  conversion function or a type conversion, then the parameter subtype
  of that function or the type mark of the type conversion must be a
  constrained array subtype, and the index ranges are obtained from
  this constrained subtype; otherwise, the index ranges are obtained
  from the object denoted by the actual designator.


vcom Message # 1190:
IEEE Std 1076-1993, 3.2.1.1 Index constraints and discrete ranges, line 410:
  If the index ranges for an interface object or member of an interface
  object are obtained from the corresponding association element, then
  they are determined either by the actual part or by the formal part
  of the association element, depending on the mode of the interface
  object, as follows:
IEEE Std 1076-1993, 3.2.1.1 Index constraints and discrete ranges, line 414:
  For an interface object or member of an interface object whose mode
  is IN, INOUT, or LINKAGE, if the actual part includes a conversion
  function or a type conversion, then the result type of that function
  or the type mark of the type conversion must be a constrained array
  subtype, and the index ranges are obtained from this constrained
  subtype; otherwise, the index ranges are obtained from the object
  denoted by the actual designator.


vcom Message # 1191:
IEEE Std 1076-1993, 3.2.1.1 Index constraints and discrete ranges, line 410:
  If the index ranges for an interface object or member of an interface
  object are obtained from the corresponding association element, then
  they are determined either by the actual part or by the formal part
  of the association element, depending on the mode of the interface
  object, as follows:
IEEE Std 1076-1993, 3.2.1.1 Index constraints and discrete ranges, line 414:
  For an interface object or member of an interface object whose mode
  is IN, INOUT, or LINKAGE, if the actual part includes a conversion
  function or a type conversion, then the result type of that function
  or the type mark of the type conversion must be a constrained array
  subtype, and the index ranges are obtained from this constrained
  subtype; otherwise, the index ranges are obtained from the object
  denoted by the actual designator.


vcom Message # 1192:
The number of elements in the array aggregate does not equal the number
of elements in the index range of the constrained array subtype at the
corresponding index position.  This is a matching element test that has
failed.


vcom Message # 1193:
The choice values given in the individual association elements of the
formal correspond to a different number of array elements than the type
of the formal has at that index position.
IEEE Std 1076-1993, 4.3.2.2 Association lists, line 506:
  Furthermore, every scalar subelement of the explicitly declared
  interface object must be associated exactly once with an actual (or
  subelement thereof) in the same association list, and all such
  associations must appear in a contiguous sequence within that
  association list.


vcom Message # 1194:
A FILE declaration was written using 1076-1987 syntax, while the
file is compiled in conformance to a newer standard (1993 or 2002).
The FILE declaration will be processed according to the 1076-1987
language rules.


vcom Message # 1195:
A selected name was used that could not be completely resolved. The suffix
does not exist within the scope of the prefix specified.


vcom Message # 1196:
The initial name of a selected name must specifiy a package,
entity, architecture, configuration, block, subprogram, or record.


vcom Message # 1197:
A selected name resolves to an object like a signal, variable,
or constant that is not valid as a component name.


vcom Message # 1198:
The identifer was determined to be a method on a protected type.
As a method of a protected type it is only visible when used in a
selected name of the form PROTECT_TYPE_NAME.METHOD or
SHARED_VARIABLE.METHOD



vcom Message # 1200:
The returned value of a function must belong to the return subtype.
For a return subtype that is a constrained array subtype, the bounds
of the returned value must match those of this subtype at every index
position in the index constraint of the array type.
[DOC: IEEE Std 1076-1993 VHDL LRM - 8.12 Return statement]


vcom Message # 1201:
An access value belongs to a corresponding subtype of an access type
either if the access value is the null value or if the value of the
designated object satisfies the constraint.
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.3 Access types]


vcom Message # 1202:
VHDL 1987 syntax does not allow an instantiated unit kind to be
specified in a component instantiation statement. Remove the keyword
or use VHDL 1993 or later (vcom options -93, -2002, etc.).


vcom Message # 1203:
The terminating string literal string bracket character was not found.
A string literal is formed by a sequence of graphic characters
(possibly none) enclosed between two quotation marks (") used as
string brackets.  The quotation marks used as string brackets at both
ends of a string literal can be replaced by percent signs (%) provided
that both string brackets are replaced and that the enclosed sequence
of characters contains no quotation marks.


vcom Message # 1204:
The terminating bit string literal bit string bracket character was not
found.  A bit string literal is formed by a sequence of extended digits
(possibly none) enclosed between two quotations (") used as bit string
brackets, preceded by a base specifier.  The quotation marks used as
bit string brackets at both ends of a bit string literal can be
replaced by percent signs (%) provided that both bit string brackets
are replaced.


vcom Message # 1205:
The character found in a bit string literal is not an extended digit.


vcom Message # 1206:
The character found in a bit string literal is not an extended digit.


vcom Message # 1207:
[13.2 Lexical elements, separators, and delimiters], line 130:
  At least one separator is required between an identifier or an
  abstract literal and an adjacent identifier or abstract literal.


vcom Message # 1208:
If a range constraint is used in a subtype indication, the type of the
expressions (likewise, of the bounds of a range attribute) must be the
same as the base type of the type mark of the subtype indication.
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.1 Scalar types]


vcom Message # 1209:
The index constraint must provide a discrete range for each index of
the array type, and the type of each discrete range must be the same as
that of the corresponding index.
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.2.1.1 Index constraints and discrete ranges]


vcom Message # 1210:
The index constraint must provide a discrete range for each index of
the array type, and the type of each discrete range must be the same as
that of the corresponding index.
[DOC: IEEE Std 1076-1993 VHDL LRM - 3.2.1.1 Index constraints and discrete ranges]


vcom Message # 1220:
An integer divide, modulo, or remainder operation has a right operand
of zero, which is causing a divide by zero error.


vcom Message # 1221:
A floating point divide has a right operand of zero, or a floating point
exponentiation has a left operand of zero and a right operand of a
negative value, which is causing a divide by zero condition.


vcom Message # 1222:
The expression did not satisfy the requirements for a CASE expression
or a selected signal assignment expression of an array type.
IEEE Std 1076-1993, 8.8 Case statement:

  If the expression is of a one-dimensional character array type, then
  the expression must be one of the following:
    -- The name of an object whose subtype is locally static
    -- An indexed name whose prefix is one of the members of this list
       and whose indexing expressions are locally static expressions
    -- A slice name whose prefix is one of the members of this list and
       whose discrete range is a locally static discrete range
    -- A function call whose return type mark denotes a locally static
       subtype
    -- A qualified expression or type conversion whose type mark
       denotes a locally static subtype

  It is an error if the element subtype of the one-dimensional character
  array type is not a locally static subtype.


vcom Message # 1223:
The expression did not satisfy the requirements for a CASE expression
or a selected signal assignment expression of an array type.
IEEE Std 1076-1993, 8.8 Case statement:

  If the expression is of a one-dimensional character array type, then
  the expression must be one of the following:
    -- The name of an object whose subtype is locally static
    -- An indexed name whose prefix is one of the members of this list
       and whose indexing expressions are locally static expressions
    -- A slice name whose prefix is one of the members of this list and
       whose discrete range is a locally static discrete range
    -- A function call whose return type mark denotes a locally static
       subtype
    -- A qualified expression or type conversion whose type mark
       denotes a locally static subtype

  It is an error if the element subtype of the one-dimensional character
  array type is not a locally static subtype.


vcom Message # 1224:
The expression did not satisfy the requirements for a CASE expression
or a selected signal assignment expression of an array type.
IEEE Std 1076-1993, 8.8 Case statement:

  If the expression is of a one-dimensional character array type, then
  the expression must be one of the following:
    -- The name of an object whose subtype is locally static
    -- An indexed name whose prefix is one of the members of this list
       and whose indexing expressions are locally static expressions
    -- A slice name whose prefix is one of the members of this list and
       whose discrete range is a locally static discrete range
    -- A function call whose return type mark denotes a locally static
       subtype
    -- A qualified expression or type conversion whose type mark
       denotes a locally static subtype

  It is an error if the element subtype of the one-dimensional character
  array type is not a locally static subtype.


vcom Message # 1225:
IEEE Std 1076-1993, 2.1.1.2 Signal parameter:

  A formal signal parameter is a guarded signal if and only if 
  it is associated with an actual signal that is a guarded signal.
  It is an error if the declaration of a formal signal parameter 
  includes the reserved word BUS. 
  (The grammar also disallows REGISTER. 


vcom Message # 1226:
It is an error if a wait statement appears in an explicit process
statement that includes a sensitivity list or in a procedure that
has a parent that is such a process statement.
[DOC: IEEE Std 1076-1993 VHDL LRM - 8.1 Wait statement]


vcom Message # 1227:
IEEE Std 1076-1987 8.2 Assertion statements. The only place the
keyword report is found in the syntactic description of VHDL 1076-1987
is within the assertion statement.


vcom Message # 1228:
IEEE Std 1076-5.2.1.1 In an entity aspect used in a binding indication
in a component configuration, The architecture is not required to exist at the time
the configuration is compiled unless there are explicit block or component configurations.
This warning message is given to remind the user that the architecture needs to exist 
by the time the design is loaded.
Note that this warning is normally issued only as part of the -lint option. 
To receive this warning outside of lint
Execute 'vcom -warning 1228 ... ' 
or make a similar change to the [msg_system] section of the modelsim.ini file.


vcom Message # 1229:
The function is making recursive calls to itself.


vcom Message # 1236:
IEEE Std 1076-2002, 4.3.1.3 Variable declarations:

  The base type of the subtype indication of a shared variable
  declaration must be a protected type.


vcom Message # 1239:
An individual association element whose formal designator is a slice
of the formal has a slice discrete range with a direction different
from the would-be direction of the formal itself.
It is an error (null slice in VHDL 1987) if the direction of the
discrete range of a slice name is not the same as that of the index
range of the array denoted by the prefix of the slice name.

However, in the case where the formal is of an unconstrained array
type (and thus the direction would normally come from the direction of
the index subtype of this base array type), the compiler will use the
direction of the first formal slice name that appears in the individual
association elements in the association list (all slices of this formal
must therefore have the same direction); this is non-compliant
behavior.
[DOC: IEEE Std 1076-1993 VHDL LRM - 6.5 Slice names]


vcom Message # 1244:
An individual association element whose formal designator is a slice
of the formal has a slice discrete range with a direction different
from a prior slice name of the same formal.  At least one of these
slice names is an error (VHDL 1993) or unsupported (VHDL 1987).


vcom Message # 1245:
The body of package std.textio can never be called.  The accelerated
implementation must be used because the package body is not an accurate
representation of the requirements of the language.


vcom Message # 1246:
The range specifice contains no value. This occurs when the direction 
is TO and LEFT is greater than RIGHT, or when the dirction is DOWNTO 
and LEFT is less than RIGHT.


vcom Message # 1247:
The range specifice contains no value. This occurs when the direction 
is TO and LEFT is greater than RIGHT, or when the dirction is DOWNTO 
and LEFT is less than RIGHT.


vcom Message # 1248:
The range specifice contains no value. This occurs when the direction 
is TO and LEFT is greater than RIGHT, or when the dirction is DOWNTO 
and LEFT is less than RIGHT.


vcom Message # 1249:
The body of package std.env can never be called.  The accelerated
implementation must be used because the package body is not an accurate
representation of the requirements of the language.


vcom Message # 1250:
The default binding for this component instantiation cannot be used.
The preceding compiler warning message contains the reason.  If the
default binding is is used, an elaboration error will be produced, and
the design will not load.  This warning can be ignored if the component
instance will be bound via an explicit binding indication as part of a
component configuration in an applicable configuration declaration.
This message can be suppressed with the vcom option -nowarn 1.


vcom Message # 1253:
The default binding for the component instantiation statement could not
created because no entity with the same name as the component could
not be found.

